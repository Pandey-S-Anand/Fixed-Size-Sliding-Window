//Bruteforce Approach

class Solution {
    /**
     * Definition of Anagram:
     * - Two strings are anagrams if they contain the same characters
     *   with the same frequencies, regardless of order.
     * Example:
     * pattern = "abc"
     * valid anagrams: "abc", "bca", "cab"
     */
    public List<Integer> findAnagrams(String text, String pattern) {
        List<Integer> startIndices = new ArrayList<>();

        // Frequency array to count characters in the current substring
        int[] windowFreqArr = new int[26];

        // Generate every possible substring of length equal to the pattern.
        for (int start = 0; start < text.length(); start++) {
            // Expand substring from the current start index
            for (int end = start; end < text.length(); end++) {
                // Add current character to frequency array
                windowFreqArr[text.charAt(end) - 'a']++;

                int substringLength = end - start + 1;

                // Process only substrings of exact pattern length
                if (substringLength == pattern.length()) {
                    // Check if current substring is an anagram
                    if (isAnagram(pattern, windowFreqArr)) {
                        startIndices.add(start);
                    }

                    // Stop expanding this window and move to next start
                    break;
                }
            }

            // Reset frequency array for the next starting index
            Arrays.fill(windowFreqArr, 0);
        }

        return startIndices;
    }

    /**
    * Checks whether the current window is an anagram of the pattern.
    *
    * Logic:
    * - For each character in the pattern:
    *     - If its frequency is zero in the window, it means either:
    *         1) The character is not present in the current window at all, OR
    *         2) The pattern contains this character more times than the window does.
    *       In both cases, the window cannot be an anagram.
    *     - Otherwise, decrement the frequency to account for one matched occurrence.
    * - If all characters of the pattern are successfully matched,
    *   the current window is an anagram.
    */
    private boolean isAnagram(String pattern, int[] windowFreqArr) {
        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (windowFreqArr[idx] == 0) {
                return false;
            }

            windowFreqArr[idx]--;
        }

        return true;
    }
}


//Better Approach

class Solution {
    /**
     * ------------------------------------------------------------
     * Why this is a FIXED-SIZE sliding window problem:
     * ------------------------------------------------------------
     * - Any anagram of `pattern` must have EXACTLY the same length
     *   as the pattern.
     * - Therefore, the window size is fixed and equal to
     *   pattern.length().
     * - We slide this fixed-size window over the text and check
     *   whether the current window forms an anagram of the pattern.
     */
    public List<Integer> findAnagrams(String text, String pattern) {
        // If pattern is longer than text, no anagram is possible
        if (pattern.length() > text.length()) {
            return Collections.emptyList();
        }

        int windowStart = 0;
        int windowEnd = 0;

        // Fixed window size equals pattern length
        int windowSize = pattern.length();

        // Stores starting indices of valid anagrams
        List<Integer> startIndices = new ArrayList<>();

        /*
         * Frequency array for the current window.
         * freqArr[i] represents how many times character (char)('a' + i)
         * appears in the current sliding window.
         */
        int[] windowFreqArr = new int[26];

        /*
         * Build the first window of size = pattern.length()
         * Count frequencies of characters in the 1st window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // Check if the first window is an anagram of the pattern
        if (isAnagram(pattern, windowFreqArr)) {
            startIndices.add(windowStart);
        }

        /*
         * Slide the window across the text:
         * - Remove the character leaving the window (windowStart)
         * - Add the character entering the window (windowEnd)
         * - After each slide, check if the window is an anagram
         */
        while (windowEnd < text.length()) {
            // Remove outgoing character (left boundary of window)
            windowFreqArr[text.charAt(windowStart++) - 'a']--;

            // Add incoming character (right boundary of window)
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;

            // Check if current window forms an anagram
            if (isAnagram(pattern, windowFreqArr)) {
                startIndices.add(windowStart);
            }
        }

        return startIndices;
    }

    /**
     * Checks whether the current window is an anagram of the pattern.
     *
     * Logic:
     * - Clone the window frequency array to avoid modifying the original state.
     * - For each character in the pattern:
     *     - If its frequency is zero in the window, it means either:
     *         1) The character is not present in the current window at all, OR
     *         2) The pattern contains this character more times than the window does.
     *       In both cases, the window cannot be an anagram.
     *     - Otherwise, decrement the frequency to account for one matched occurrence.
     * - If all characters of the pattern are successfully matched,
     *   the current window is an anagram.
     */
    private boolean isAnagram(String pattern, int[] windowFreqArr) {
        windowFreqArr = windowFreqArr.clone();

        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (windowFreqArr[idx] == 0) {
                return false;
            }
            windowFreqArr[idx]--;
        }

        return true;
    }
}


//Optimal Approach

class Solution {
    public List<Integer> findAnagrams(String text, String pattern) {
        if (pattern.length() > text.length()) {
            return Collections.emptyList();
        }

        List<Integer> startIndices = new ArrayList<>();

        /*
         * patternFreqArr:
         * Stores frequency of each character in the pattern.
         *
         * windowFreqArr:
         * Stores frequency of each character in the current window of text.
         */
        int[] patternFreqArr = new int[26];
        int[] windowFreqArr = new int[26];

        // Build frequency array for the pattern
        for (int i = 0; i < pattern.length(); i++) {
            patternFreqArr[pattern.charAt(i) - 'a']++;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * Build the FIRST window of size = pattern length.
         * Count frequencies of characters in this initial window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // If first window's frequency matches the pattern, first window is an anagram
        if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
            startIndices.add(windowStart);
        }

        while (windowEnd < text.length()) {
            // Remove outgoing character
            windowFreqArr[text.charAt(windowStart++) - 'a']--;

            // Add incoming character
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;

            // Check if current window is a anagram of the pattern
            if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
                startIndices.add(windowStart);
            }
        }

        return startIndices;
    }

    /**
     * Compares two frequency arrays.
     *
     * Logic:
     * - If frequencies of ALL characters ('a' to 'z') are equal,
     *   then the two strings are anagrams of each other.
     */
    private boolean areFrequenciesEqual(int[] windowFreqArr, int[] patternFreqArr) {
        for (int i = 0; i < 26; i++) {
            if (windowFreqArr[i] != patternFreqArr[i]) {
                return false;
            }
        }

        return true;
    }
}
