//Bruteforce Approach

class Solution {
    /**
     * Brute-force approach to check whether str2
     * contains any permutation of str1.
     *
     * ------------------------------------------------------------
     * What does "permutation" mean here?
     * ------------------------------------------------------------
     * - A permutation of str1 is any reordering of its characters.
     * - Example:
     *     str1 = "ab"
     *     Valid permutations: "ab", "ba"
     *
     * If any substring of str2 of length = str1.length()
     * is a permutation of str1, we return true.
     *
     */
    public boolean checkInclusion(String str1, String str2) {
        // If str1 is longer than str2, it is impossible for any substring of str2 to be a permutation of str1.
        if (str1.length() > str2.length()) {
            return false;
        }

        // Frequency array for the current substring window
        int[] windowFreqArr = new int[26];

        // Generate all possible substrings of str2
        for (int start = 0; start < str2.length(); start++) {
            // Expand substring starting at index 'start'
            for (int end = start; end < str2.length(); end++) {
                // Add current character to frequency array
                windowFreqArr[str2.charAt(end) - 'a']++;

                int substringLength = end - start + 1;

                // Process only substrings of exact length = str1.length()
                if (substringLength == str1.length()) {
                    // Check if current substring is a permutation of str1
                    if (containsPermutation(str1, windowFreqArr)) {
                        return true;
                    }

                    // Stop expanding this window and move to next start
                    break;
                }
            }

            // Reset frequency array for the next starting index
            Arrays.fill(windowFreqArr, 0);
        }

        return false;
    }

    /**
     * Checks whether the current window can form
     * a permutation of str1.
     *
     * Logic:
     * - For each character in str1:
     *     - If its frequency in the window is zero,
     *       it means:
     *         1) The character does not exist in the window, OR
     *         2) The window does not have enough occurrences.
     *       Hence, it cannot be a permutation.
     *     - Otherwise, decrement its frequency to mark usage.
     *
     * If all characters of str1 are successfully matched,
     * the window contains a valid permutation.
     */
    private boolean containsPermutation(String str, int[] windowFreqArr) {
        for (int i = 0; i < str.length(); i++) {
            int idx = str.charAt(i) - 'a';

            if (windowFreqArr[idx] == 0) {
                return false;
            }

            windowFreqArr[idx]--;
        }

        return true;
    }
}



//Better Approach

class Solution {
    /**
     * Checks whether text contains any permutation of pattern.
     *
     * ------------------------------------------------------------
     * Key Insight:
     * ------------------------------------------------------------
     * - A permutation of a string is simply an anagram of that string.
     * - Therefore:
     *     "Does text contain a permutation of pattern?"
     *   becomes:
     *     "Does text contain any substring which is an anagram of pattern?"
     *
     * ------------------------------------------------------------
     * Why this is a FIXED-SIZE Sliding Window problem:
     * ------------------------------------------------------------
     * - Any permutation (anagram) of pattern must have the same length
     *   as pattern.
     * - Hence, we slide a window of fixed size = pattern.length()
     *   across text and check each window.
     */
    public boolean checkInclusion(String pattern, String text) {
        // If pattern is longer than text, permutation is impossible
        if (pattern.length() > text.length()) {
            return false;
        }

        int windowStart = 0;
        int windowEnd = 0;

        // Fixed window size equals length of pattern
        int windowSize = pattern.length();

        /*
        * Frequency array for the current window.
        * windowFreqArr[i] represents how many times character (char)('a' + i)
        * appears in the current window.
        */
        int[] windowFreqArr = new int[26];

        /*
         * Build the first window of size = pattern.length()
         * Count frequencies of characters in the initial window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;
        }

        // Check if the first window is an anagram of pattern
        if (isAnagram(pattern, windowFreqArr)) {
            return true;
        }

        /*
         * Slide the window across text:
         * - Remove the character leaving the window (left boundary)
         * - Add the character entering the window (right boundary)
         * - After each slide, check if the window is an anagram
         */
        while (windowEnd < text.length()) {
            // Remove outgoing character
            windowFreqArr[text.charAt(windowStart) - 'a']--;
            windowStart++;

            // Add incoming character
            windowFreqArr[text.charAt(windowEnd) - 'a']++;

            // Check if current window forms a permutation of pattern
            if (isAnagram(pattern, windowFreqArr)) {
                return true;
            }

            windowEnd++;
        }

        // No permutation found
        return false;
    }

    /**
    * Checks whether the current window is an anagram of the pattern.
    *
    * Logic:
    * - Clone the window frequency array to avoid modifying the original state.
    * - For each character in the pattern:
    *     - If its frequency is zero in the window, it means either:
    *         1) The character is not present in the current window at all, OR
    *         2) The pattern contains this character more times than the window does.
    *       In both cases, the window cannot be an anagram.
    *     - Otherwise, decrement the frequency to account for one matched occurrence.
    * - If all characters of the pattern are successfully matched,
    *   the current window is an anagram.
    */
    private boolean isAnagram(String pattern, int[] windowFreqArr) {
        // Clone to avoid mutating original frequency array
        windowFreqArr = windowFreqArr.clone();

        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (windowFreqArr[idx] == 0) {
                return false;
            }

            windowFreqArr[idx]--;
        }

        return true;
    }
}


//Optimal Approach 

class Solution {
    public boolean checkInclusion(String pattern, String text) {
        if (pattern.length() > text.length()) {
            return false;
        }

        /*
         * patternFreqArr:
         * Stores frequency of each character in the pattern.
         *
         * windowFreqArr:
         * Stores frequency of each character in the current window of text.
         */
        int[] patternFreqArr = new int[26];
        int[] windowFreqArr = new int[26];

        // Build frequency array for the pattern
        for (int i = 0; i < pattern.length(); i++) {
            patternFreqArr[pattern.charAt(i) - 'a']++;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * Build the FIRST window of size = pattern length.
         * Count frequencies of characters in this initial window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;
        }

        // If first window's frequency matches the pattern, permutation found
        if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
            return true;
        }

        while (windowEnd < text.length()) {
            // Remove outgoing character
            windowFreqArr[text.charAt(windowStart++) - 'a']--;

            // Add incoming character
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;

            // Check if current window is a permutation of the pattern
            if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
                return true;
            }
        }

        // No permutation found in any window
        return false;
    }

    /**
     * Compares two frequency arrays.
     *
     * Logic:
     * - If frequencies of ALL characters ('a' to 'z') are equal,
     *   then the two strings are anagrams of each other.
     */
    private boolean areFrequenciesEqual(int[] patternFreqArr, int[] windowFreqArr) {
        for (int i = 0; i < 26; i++) {
            if (patternFreqArr[i] != windowFreqArr[i]) {
                return false;
            }
        }

        return true;
    }
}
